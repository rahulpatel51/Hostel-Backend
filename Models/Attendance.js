import mongoose from "mongoose";

const attendanceSchema = new mongoose.Schema(
  {
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Student",
      required: [true, "Student ID is required"],
      index: true
    },
    date: {
      type: Date,
      required: [true, "Date is required"],
      index: true,
      validate: {
        validator: function(value) {
          return value instanceof Date && !isNaN(value.getTime());
        },
        message: "Invalid date format"
      }
    },
    morningStatus: {
      type: String,
      enum: {
        values: ["present", "absent"],
        message: "Invalid morning status"
      },
      default: "absent",
      required: [true, "Morning status is required"]
    },
    eveningStatus: {
      type: String,
      enum: {
        values: ["present", "absent"],
        message: "Invalid evening status"
      },
      default: "absent",
      required: [true, "Evening status is required"]
    },
    markedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: [true, "Marked by user is required"]
    },
    remarks: {
      type: String,
      maxlength: [500, "Remarks cannot exceed 500 characters"],
      trim: true
    },
    session: {
      type: String,
      enum: {
        values: ["morning", "evening"],
        message: "Invalid session type"
      },
      required: [true, "Session type is required"]
    },
    isAutoGenerated: {
      type: Boolean,
      default: false
    }
  },
  { 
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
);

// Virtual for formatted date (YYYY-MM-DD)
attendanceSchema.virtual("formattedDate").get(function() {
  return this.date.toISOString().split('T')[0];
});

// Compound index for unique attendance per student per day
attendanceSchema.index(
  { student: 1, date: 1 }, 
  { 
    unique: true,
    partialFilterExpression: {
      isAutoGenerated: { $ne: true }
    }
  }
);

// Index for faster queries by date range
attendanceSchema.index({ date: 1, student: 1 });

// Pre-save hook to validate data
attendanceSchema.pre("save", function(next) {
  if (this.isModified("date")) {
    this.date = new Date(this.date.setHours(0, 0, 0, 0));
  }
  next();
});

// Static method to get attendance by student and date range
attendanceSchema.statics.findByStudentAndDateRange = async function(
  studentId,
  startDate,
  endDate
) {
  return this.find({
    student: studentId,
    date: {
      $gte: new Date(startDate),
      $lte: new Date(endDate)
    }
  }).sort({ date: 1 });
};

// Static method for bulk attendance operations
attendanceSchema.statics.bulkUpsert = async function(records) {
  const operations = records.map(record => ({
    updateOne: {
      filter: {
        student: record.student,
        date: record.date
      },
      update: { $set: record },
      upsert: true
    }
  }));
  return this.bulkWrite(operations);
};

// Instance method to get attendance summary
attendanceSchema.methods.getSummary = function() {
  return {
    student: this.student,
    date: this.formattedDate,
    morning: this.morningStatus,
    evening: this.eveningStatus,
    markedBy: this.markedBy
  };
};

const Attendance = mongoose.model("Attendance", attendanceSchema);

export default Attendance;